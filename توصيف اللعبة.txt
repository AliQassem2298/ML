1. توصيف الحالة:
الحالة هنا تمثل توزيع القطع المغناطيسية وقطع الحديد والعوائق على لوحة ثنائية الأبعاد، إضافةً إلى تحديد مواقع الأهداف (الأماكن التي يجب على المغناطيس الوصول إليها).
تتضمن مكونات الحالة:
H: قطعة الحديد (غير قابلة للتحريك مباشرة، تتأثر بالتنافر أو التجاذب مع المغناطيسات).
T: الهدف (الخلايا التي يجب أن تحتوي على مغناطيس او قطعة حديد لتحقيق الفوز).
P: مغناطيس ارجواني (خاص بالتنافر).
R: مغناطيس احمر (خاص بالتجاذب).
B: عازل (لا يمكن تجاوزه).
(H/P/R)+T: تعني قطعة على هدف، أي أن هناك مغناطيسا أو قطعة حديد موجودة على خلية الهدف.
قمت باستخدام المصفوفة الثنائية لتمثيل الصفوف والأعمدة وكل قطعة يعبر عنها ب احداثياتها ونوعها أي انه: (row,col,piece_type)
وقمت ب استخدام المجموعة (set) لمصفوفة الحالات المزارة visited.
لأنها تمنع التكرار لكي لا تقع خورازميات البحث BFS,DFS بحلقة لا نهائية
وفي خوارزميات البحث قمت بتمثيل الحالات على هيئة tuple لمقارنة الحالات بشكل اسرع وبحيث تكون مرتبة لتسهيل المقارنة.
2. فضاء الحالات:
يمثل فضاء الحالات جميع التوزيعات الممكنة للقطع المغناطيسية وقطع الحديد على اللوحة. ينتج فضاء الحالات
عن تحريك المغناطيسات (الأرجوانية والحمراء) في الاتجاهات الممكنة (أعلى، أسفل، يسار، يمين)، مما يؤدي إلى
تغييرات على مواقع القطع وتفاعلات التجاذب أو التنافر. يتم تمثيل كل حالة على هيئة مصفوفة للحالة، ويُحتفظ
بجميع الحالات التي زارتها الخوارزمية في مجموعة visited_states لتجنب الحلقات غير المنتهية.

3. الحالة الابتدائية: هي حالة البداية التي يتم فيها توزيع القطع على اللوحة بشكل معين (يدويا أو عشوائيًا)، ويتم فيها تحديد مواقع
الأهداف، وتبدأ منها خوارزميات البحث للبحث عن حل.
قمت بإنشاء object من الكلاس الأساسي MagneticPuzzleBoard بتمرير عدد الصفوف والاعمدة ليقوم ب انشاء الرقعة (مصفوفة ثنائية).
وقمت بوضع فيها قطعة معدنية ومغناطيس ارجواني وهدفان (موجودة في ال code).
4. العمليات والإجراءات وشرح التوابع:
__init__: تهيئة اللوحة وتحديد أبعادها.
is_within_bounds: بتحقق فيما اذا كانت الاحداثيات المرسلة داخل حدود الرقعة او لا.
is_empty_or_target: يتحقق فيما اذا كانت القطعة فارغة او هدف لتحديد ما إذا كانت صالحة للتحريك.
place_piece: تابع لوضع قطعة معينة (حديدة او مغناطيس احمر او مغناطيس ارجواني) بمكان محدد مع تحديد نوعها.
place_target: تابع لوضع هدف في مكان معين ب ارسال الاحداثيات اليه.
display: تابع لطباعة الرقعة بشكل مرئي مع مراعاة توصيف الحالة.
can_move: تابع يتحقق فيما اذا كانت القطعة قادرة على التحرك في الاتجاهات الأربعة.
move_piece: تابع يحرك القطعة اذا كانت قادرة على التحرك في تابع can_move وتحديث اللوحة وفقًا لقواعد التجاذب والتنافر.
clone_board: تابع يقوم بنسخ الرقعة الحالية لإنشاء حالات جديدة في فضاء البحث ولكي لا يتم التعديل على الرقعة الأساسية مباشرة.
apply_repulsionوapply_attractionوrepulse_pieceوattract_piece_toward: توابع لتطبيق مبدأ التنافر والتجاذب على القطع حسب شروط المسألة.
random_fill_board: يقوم ب ملئ الرقعة تلقائياً بشكل عشوائي ب أنواع القطع المختلفة.
move_magnet_to_position: تحريك المغناطيس من موقعه الحالي الى أي موقع متاح على اللوحة (فارغ او هدف).
check_win: تابع يتحقق من شرط الفوز انه اذا كانت لا يوجد قطع اهداف بدون قطع تشغلها (حرف T لوحده في أي خانة).
state_as_tuple: تحويل الحالة الحالية إلى صيغة tuple لتمثيلها بشكل فريد وتجنب التكرار.
generate_possible_moves: يقوم بتوليد الحركات المسموحة للمغناطيسات بناء على تابع can_move ويرجى ملاحظة ان ترتيب الاتجاهات ضمن مصفوفة ال directions يختلف أي ان الترتيب مهم في الادخال الى ال queue او الstack.
bfs: تستخدم خوارزمية البحث بعرض أول (BFS) لاستكشاف جميع الحركات الممكنة والوصول إلى حالة الفوز، مع الاحتفاظ بالحالات المزارة في visited_states لتجنب التكرار وبنية المعطيات المستخدمة هي queue تعمل بمبدأ ال first_in_first_out.
dfs: تستخدم خوارزمية البحث بعمق أول (DFS) لنفس الهدف، ولكن بتوجه مختلف لاستكشاف الحالات بنية المعطيات المستخدمة هي stack تعمل بمبدأ ال last_in_first_out.
قمت بمقارنة كل حالة نوصل اليها مع شرط الفوز في تابع check_win اذا كان لا يوجد مواقع هدف بدون ان تكون مشغولة ب قطعة حديد او مغناطيس ب انواعه.
usc: تستخدم للبحث عن أقل تكلفة لتحقيق الحالة النهائية ونعرف التكلفة بأنها عدد الحركات التي يتم تنفيذها للوصول إلى الحل.
نضيف الحالة البدائية إلى قائمة الأولويات مع تكلفة ابتدائية تساوي صفرًا.
ويتم اختيار الحالة ذات التكلفة الأقل من قائمة الأولويات.
تُولد جميع الحالات الممكنة من الحالة الحالية باستخدام تابع generate_possible_states.
يتم تعيين تكلفة لكل حالة جديدة بناءً على عدد الحركات المؤدية إليها. (1+)
يتم تخزين الحالات التي تمت زيارتها لتجنب تكرار البحث.
يمثل فضاء البحث جميع الحركات الممكنة على اللوحة مع ترتيبها بناءً على التكلفة. يتم تحقيق حالة الهدف باستخدام أقل عدد من الحركات.
5. الحالة النهائية:
الحالة النهائية هي الحالة التي تتحقق فيها شروط الفوز، حيث تصل المغناطيسات إلى جميع الأهداف المحددة على اللوحة (أي أن كل خلية هدف T تحتوي على مغناطيس).
